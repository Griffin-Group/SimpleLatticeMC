import numpy as np
import sys
from calculate_couplings import auto_generate_adjacency

# only does symmetric unit cell
def write_unitcell(a0, d, vdw, vac, outputfile, supercell, occstring, interc):

    a0 = a0*supercell
    occvec = [int(el) for el in occstring]
    nFe = np.sum(occvec)
    u1 = u2 = 0 # no shifting here

    # corresponds to 'HAP' phase in the FeTaS2-TEM-interfaces scripts: a 2H bilayer, MM aligned phase
    o1, o2 = 2/3, 1/3 
    o3, o4 = 2/3, 1/3  
    o5, o6 = 1/3, 2/3  
    o7, o8 = 1/3, 2/3 
 
    # make the lattice vector lines
    c = vac + (2*vdw+4*d)
    lines = []
    lines.append("Autogenerated, a0={}, vdw={}, d={}, vac={}, u=({},{}), occ={}\n".format(a0, vdw, d, vac, u1, u2, occstring))
    lines.append("1.00000000000000\n")
    lines.append("{}   0.0    0.0\n".format(a0))
    lines.append("{}   {}    0.0\n".format(-a0/2, np.sqrt(3)*a0/2))
    lines.append("0.0   0.0    {}\n".format(c))
    lines.append("Ta   S   {} \n".format(interc))
    lines.append("{}   {}   {} \n".format(int(2*supercell*supercell), int(4*supercell*supercell), nFe))
    lines.append("Selective dynamics\n")
    lines.append("Direct\n")
    
    # make the atomic position lines, relative coordinates
    compound_ij = 0
    basis_vecs = []
    for i in range(supercell):
        for j in range(supercell):
            # bottom layer Ta
            lines.append("{}  {}  {}  F   F   F \n".format(i/supercell,j/supercell,d/c))
            # top layer Ta    
            lines.append("{}  {}  {}  F   F   F \n".format(i/supercell+u1,j/supercell+u2,(3*d+vdw)/c))
    for i in range(supercell):
        for j in range(supercell):
            # bottom layer S
            lines.append("{}  {}  {}  F   F   F \n".format(i/supercell+o1, j/supercell+o2, 0.0))
            lines.append("{}  {}  {}  F   F   F \n".format(i/supercell+o3, j/supercell+o4, (2*d)/c))
            # top layer S
            lines.append("{}  {}  {}  F   F   F \n".format(i/supercell+o5+u1, j/supercell+o6+u2, (2*d+vdw)/c))
            lines.append("{}  {}  {}  F   F   F \n".format(i/supercell+o7+u1, j/supercell+o8+u2, (4*d+vdw)/c))
    for i in range(supercell):
        for j in range(supercell):
            # intercalants
            if occvec[compound_ij]: 
                lines.append("{}  {}  {}  T   T   T \n".format(i/supercell+u1,j/supercell+u2,(2*d+vdw*0.5)/c))
                basis_vecs.append([i/supercell+u1,j/supercell+u2])
            compound_ij += 1

    # write
    with open(outputfile, 'w') as f: f.write(''.join(lines))

    # prints the adjacency information (how many interactions of each length etc)
    print('Working on {}'.format(sys.argv[5]))
    a1 = np.array([a0, 0.0])
    a2 = np.array([-a0/2, np.sqrt(3)*a0/2])
    auto_generate_adjacency(a1, a2, basis_vecs, a0)
                           
if __name__ == '__main__':
    write_unitcell( float(sys.argv[1]), #a0
                    float(sys.argv[2]), #d
                    float(sys.argv[3]), #vdw
                    float(sys.argv[4]), #vac
                    sys.argv[5],        #output
                    int(sys.argv[6]),   #supercell
                    sys.argv[7],        #occstring
                    sys.argv[8])        #intercalant



